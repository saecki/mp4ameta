// IMPORTANT: This file is automatically generated!
// Edit the `generate.toml` file and run the code generation from the repository root
// with the following command: `cargo run --manifest-path=gen/Cargo.toml`

use crate::{ident, Data, Userdata};

/// ### Album
impl Userdata {
    /// Returns the album (`©alb`).
    pub fn album(&self) -> Option<&str> {
        self.strings_of(&ident::ALBUM).next()
    }

    /// Removes and returns the album (`©alb`).
    pub fn take_album(&mut self) -> Option<String> {
        self.take_strings_of(&ident::ALBUM).next()
    }

    /// Sets the album (`©alb`).
    pub fn set_album(&mut self, album: impl Into<String>) {
        self.set_data(ident::ALBUM, Data::Utf8(album.into()));
    }

    /// Removes the album (`©alb`).
    pub fn remove_album(&mut self) {
        self.remove_data_of(&ident::ALBUM);
    }

    /// Returns the album formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_album(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.album() {
            Some(s) => writeln!(f, "album: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Copyright
impl Userdata {
    /// Returns the copyright (`cprt`).
    pub fn copyright(&self) -> Option<&str> {
        self.strings_of(&ident::COPYRIGHT).next()
    }

    /// Removes and returns the copyright (`cprt`).
    pub fn take_copyright(&mut self) -> Option<String> {
        self.take_strings_of(&ident::COPYRIGHT).next()
    }

    /// Sets the copyright (`cprt`).
    pub fn set_copyright(&mut self, copyright: impl Into<String>) {
        self.set_data(ident::COPYRIGHT, Data::Utf8(copyright.into()));
    }

    /// Removes the copyright (`cprt`).
    pub fn remove_copyright(&mut self) {
        self.remove_data_of(&ident::COPYRIGHT);
    }

    /// Returns the copyright formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_copyright(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.copyright() {
            Some(s) => writeln!(f, "copyright: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Encoder
impl Userdata {
    /// Returns the encoder (`©too`).
    pub fn encoder(&self) -> Option<&str> {
        self.strings_of(&ident::ENCODER).next()
    }

    /// Removes and returns the encoder (`©too`).
    pub fn take_encoder(&mut self) -> Option<String> {
        self.take_strings_of(&ident::ENCODER).next()
    }

    /// Sets the encoder (`©too`).
    pub fn set_encoder(&mut self, encoder: impl Into<String>) {
        self.set_data(ident::ENCODER, Data::Utf8(encoder.into()));
    }

    /// Removes the encoder (`©too`).
    pub fn remove_encoder(&mut self) {
        self.remove_data_of(&ident::ENCODER);
    }

    /// Returns the encoder formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_encoder(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.encoder() {
            Some(s) => writeln!(f, "encoder: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Lyrics
impl Userdata {
    /// Returns the lyrics (`©lyr`).
    pub fn lyrics(&self) -> Option<&str> {
        self.strings_of(&ident::LYRICS).next()
    }

    /// Removes and returns the lyrics (`©lyr`).
    pub fn take_lyrics(&mut self) -> Option<String> {
        self.take_strings_of(&ident::LYRICS).next()
    }

    /// Sets the lyrics (`©lyr`).
    pub fn set_lyrics(&mut self, lyrics: impl Into<String>) {
        self.set_data(ident::LYRICS, Data::Utf8(lyrics.into()));
    }

    /// Removes the lyrics (`©lyr`).
    pub fn remove_lyrics(&mut self) {
        self.remove_data_of(&ident::LYRICS);
    }

    /// Returns the lyrics formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_lyrics(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.lyrics() {
            Some(s) => writeln!(f, "lyrics: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Movement
impl Userdata {
    /// Returns the movement (`©mvn`).
    pub fn movement(&self) -> Option<&str> {
        self.strings_of(&ident::MOVEMENT).next()
    }

    /// Removes and returns the movement (`©mvn`).
    pub fn take_movement(&mut self) -> Option<String> {
        self.take_strings_of(&ident::MOVEMENT).next()
    }

    /// Sets the movement (`©mvn`).
    pub fn set_movement(&mut self, movement: impl Into<String>) {
        self.set_data(ident::MOVEMENT, Data::Utf8(movement.into()));
    }

    /// Removes the movement (`©mvn`).
    pub fn remove_movement(&mut self) {
        self.remove_data_of(&ident::MOVEMENT);
    }

    /// Returns the movement formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_movement(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.movement() {
            Some(s) => writeln!(f, "movement: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Title
impl Userdata {
    /// Returns the title (`©nam`).
    pub fn title(&self) -> Option<&str> {
        self.strings_of(&ident::TITLE).next()
    }

    /// Removes and returns the title (`©nam`).
    pub fn take_title(&mut self) -> Option<String> {
        self.take_strings_of(&ident::TITLE).next()
    }

    /// Sets the title (`©nam`).
    pub fn set_title(&mut self, title: impl Into<String>) {
        self.set_data(ident::TITLE, Data::Utf8(title.into()));
    }

    /// Removes the title (`©nam`).
    pub fn remove_title(&mut self) {
        self.remove_data_of(&ident::TITLE);
    }

    /// Returns the title formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_title(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.title() {
            Some(s) => writeln!(f, "title: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Tv episode name
impl Userdata {
    /// Returns the tv episode name (`tven`).
    pub fn tv_episode_name(&self) -> Option<&str> {
        self.strings_of(&ident::TV_EPISODE_NAME).next()
    }

    /// Removes and returns the tv episode name (`tven`).
    pub fn take_tv_episode_name(&mut self) -> Option<String> {
        self.take_strings_of(&ident::TV_EPISODE_NAME).next()
    }

    /// Sets the tv episode name (`tven`).
    pub fn set_tv_episode_name(&mut self, tv_episode_name: impl Into<String>) {
        self.set_data(ident::TV_EPISODE_NAME, Data::Utf8(tv_episode_name.into()));
    }

    /// Removes the tv episode name (`tven`).
    pub fn remove_tv_episode_name(&mut self) {
        self.remove_data_of(&ident::TV_EPISODE_NAME);
    }

    /// Returns the tv episode name formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_tv_episode_name(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.tv_episode_name() {
            Some(s) => writeln!(f, "tv episode name: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Tv network name
impl Userdata {
    /// Returns the tv network name (`tvnn`).
    pub fn tv_network_name(&self) -> Option<&str> {
        self.strings_of(&ident::TV_NETWORK_NAME).next()
    }

    /// Removes and returns the tv network name (`tvnn`).
    pub fn take_tv_network_name(&mut self) -> Option<String> {
        self.take_strings_of(&ident::TV_NETWORK_NAME).next()
    }

    /// Sets the tv network name (`tvnn`).
    pub fn set_tv_network_name(&mut self, tv_network_name: impl Into<String>) {
        self.set_data(ident::TV_NETWORK_NAME, Data::Utf8(tv_network_name.into()));
    }

    /// Removes the tv network name (`tvnn`).
    pub fn remove_tv_network_name(&mut self) {
        self.remove_data_of(&ident::TV_NETWORK_NAME);
    }

    /// Returns the tv network name formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_tv_network_name(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.tv_network_name() {
            Some(s) => writeln!(f, "tv network name: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Tv show name
impl Userdata {
    /// Returns the tv show name (`tvsh`).
    pub fn tv_show_name(&self) -> Option<&str> {
        self.strings_of(&ident::TV_SHOW_NAME).next()
    }

    /// Removes and returns the tv show name (`tvsh`).
    pub fn take_tv_show_name(&mut self) -> Option<String> {
        self.take_strings_of(&ident::TV_SHOW_NAME).next()
    }

    /// Sets the tv show name (`tvsh`).
    pub fn set_tv_show_name(&mut self, tv_show_name: impl Into<String>) {
        self.set_data(ident::TV_SHOW_NAME, Data::Utf8(tv_show_name.into()));
    }

    /// Removes the tv show name (`tvsh`).
    pub fn remove_tv_show_name(&mut self) {
        self.remove_data_of(&ident::TV_SHOW_NAME);
    }

    /// Returns the tv show name formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_tv_show_name(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.tv_show_name() {
            Some(s) => writeln!(f, "tv show name: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Work
impl Userdata {
    /// Returns the work (`©wrk`).
    pub fn work(&self) -> Option<&str> {
        self.strings_of(&ident::WORK).next()
    }

    /// Removes and returns the work (`©wrk`).
    pub fn take_work(&mut self) -> Option<String> {
        self.take_strings_of(&ident::WORK).next()
    }

    /// Sets the work (`©wrk`).
    pub fn set_work(&mut self, work: impl Into<String>) {
        self.set_data(ident::WORK, Data::Utf8(work.into()));
    }

    /// Removes the work (`©wrk`).
    pub fn remove_work(&mut self) {
        self.remove_data_of(&ident::WORK);
    }

    /// Returns the work formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_work(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.work() {
            Some(s) => writeln!(f, "work: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Year
impl Userdata {
    /// Returns the year (`©day`).
    pub fn year(&self) -> Option<&str> {
        self.strings_of(&ident::YEAR).next()
    }

    /// Removes and returns the year (`©day`).
    pub fn take_year(&mut self) -> Option<String> {
        self.take_strings_of(&ident::YEAR).next()
    }

    /// Sets the year (`©day`).
    pub fn set_year(&mut self, year: impl Into<String>) {
        self.set_data(ident::YEAR, Data::Utf8(year.into()));
    }

    /// Removes the year (`©day`).
    pub fn remove_year(&mut self) {
        self.remove_data_of(&ident::YEAR);
    }

    /// Returns the year formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_year(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.year() {
            Some(s) => writeln!(f, "year: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Isrc
impl Userdata {
    /// Returns the isrc (`----:com.apple.iTunes:ISRC`).
    pub fn isrc(&self) -> Option<&str> {
        self.strings_of(&ident::ISRC).next()
    }

    /// Removes and returns the isrc (`----:com.apple.iTunes:ISRC`).
    pub fn take_isrc(&mut self) -> Option<String> {
        self.take_strings_of(&ident::ISRC).next()
    }

    /// Sets the isrc (`----:com.apple.iTunes:ISRC`).
    pub fn set_isrc(&mut self, isrc: impl Into<String>) {
        self.set_data(ident::ISRC, Data::Utf8(isrc.into()));
    }

    /// Removes the isrc (`----:com.apple.iTunes:ISRC`).
    pub fn remove_isrc(&mut self) {
        self.remove_data_of(&ident::ISRC);
    }

    /// Returns the isrc formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_isrc(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.isrc() {
            Some(s) => writeln!(f, "isrc: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Album artist
impl Userdata {
    /// Returns all album artists (`aART`).
    pub fn album_artists(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::ALBUM_ARTIST)
    }

    /// Returns the first album artist (`aART`).
    pub fn album_artist(&self) -> Option<&str> {
        self.strings_of(&ident::ALBUM_ARTIST).next()
    }

    /// Removes and returns all album artists (`aART`).
    pub fn take_album_artists(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::ALBUM_ARTIST)
    }

    /// Removes all and returns the first album artist (`aART`).
    pub fn take_album_artist(&mut self) -> Option<String> {
        self.take_strings_of(&ident::ALBUM_ARTIST).next()
    }

    /// Sets all album artists (`aART`). This will remove all other album artists.
    pub fn set_album_artists(&mut self, album_artists: impl IntoIterator<Item = String>) {
        let data = album_artists.into_iter().map(Data::Utf8);
        self.set_all_data(ident::ALBUM_ARTIST, data);
    }

    /// Sets the album artist (`aART`). This will remove all other album artists.
    pub fn set_album_artist(&mut self, album_artist: impl Into<String>) {
        self.set_data(ident::ALBUM_ARTIST, Data::Utf8(album_artist.into()));
    }

    /// Adds all album artists (`aART`).
    pub fn add_album_artists(&mut self, album_artists: impl IntoIterator<Item = String>) {
        let data = album_artists.into_iter().map(Data::Utf8);
        self.add_all_data(ident::ALBUM_ARTIST, data);
    }

    /// Adds an album artist (`aART`).
    pub fn add_album_artist(&mut self, album_artist: impl Into<String>) {
        self.add_data(ident::ALBUM_ARTIST, Data::Utf8(album_artist.into()));
    }

    /// Removes all album artists (`aART`).
    pub fn remove_album_artists(&mut self) {
        self.remove_data_of(&ident::ALBUM_ARTIST);
    }

    /// Returns all album artists formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_album_artists(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.album_artists().count() > 1 {
            writeln!(f, "album artists:")?;
            for s in self.album_artists() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.album_artist() {
            writeln!(f, "album artist: {}", s)?;
        }
        Ok(())
    }
}

/// ### Artist
impl Userdata {
    /// Returns all artists (`©ART`).
    pub fn artists(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::ARTIST)
    }

    /// Returns the first artist (`©ART`).
    pub fn artist(&self) -> Option<&str> {
        self.strings_of(&ident::ARTIST).next()
    }

    /// Removes and returns all artists (`©ART`).
    pub fn take_artists(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::ARTIST)
    }

    /// Removes all and returns the first artist (`©ART`).
    pub fn take_artist(&mut self) -> Option<String> {
        self.take_strings_of(&ident::ARTIST).next()
    }

    /// Sets all artists (`©ART`). This will remove all other artists.
    pub fn set_artists(&mut self, artists: impl IntoIterator<Item = String>) {
        let data = artists.into_iter().map(Data::Utf8);
        self.set_all_data(ident::ARTIST, data);
    }

    /// Sets the artist (`©ART`). This will remove all other artists.
    pub fn set_artist(&mut self, artist: impl Into<String>) {
        self.set_data(ident::ARTIST, Data::Utf8(artist.into()));
    }

    /// Adds all artists (`©ART`).
    pub fn add_artists(&mut self, artists: impl IntoIterator<Item = String>) {
        let data = artists.into_iter().map(Data::Utf8);
        self.add_all_data(ident::ARTIST, data);
    }

    /// Adds an artist (`©ART`).
    pub fn add_artist(&mut self, artist: impl Into<String>) {
        self.add_data(ident::ARTIST, Data::Utf8(artist.into()));
    }

    /// Removes all artists (`©ART`).
    pub fn remove_artists(&mut self) {
        self.remove_data_of(&ident::ARTIST);
    }

    /// Returns all artists formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_artists(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.artists().count() > 1 {
            writeln!(f, "artists:")?;
            for s in self.artists() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.artist() {
            writeln!(f, "artist: {}", s)?;
        }
        Ok(())
    }
}

/// ### Category
impl Userdata {
    /// Returns all categories (`catg`).
    pub fn categories(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::CATEGORY)
    }

    /// Returns the first category (`catg`).
    pub fn category(&self) -> Option<&str> {
        self.strings_of(&ident::CATEGORY).next()
    }

    /// Removes and returns all categories (`catg`).
    pub fn take_categories(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::CATEGORY)
    }

    /// Removes all and returns the first category (`catg`).
    pub fn take_category(&mut self) -> Option<String> {
        self.take_strings_of(&ident::CATEGORY).next()
    }

    /// Sets all categories (`catg`). This will remove all other categories.
    pub fn set_categories(&mut self, categories: impl IntoIterator<Item = String>) {
        let data = categories.into_iter().map(Data::Utf8);
        self.set_all_data(ident::CATEGORY, data);
    }

    /// Sets the category (`catg`). This will remove all other categories.
    pub fn set_category(&mut self, category: impl Into<String>) {
        self.set_data(ident::CATEGORY, Data::Utf8(category.into()));
    }

    /// Adds all categories (`catg`).
    pub fn add_categories(&mut self, categories: impl IntoIterator<Item = String>) {
        let data = categories.into_iter().map(Data::Utf8);
        self.add_all_data(ident::CATEGORY, data);
    }

    /// Adds an category (`catg`).
    pub fn add_category(&mut self, category: impl Into<String>) {
        self.add_data(ident::CATEGORY, Data::Utf8(category.into()));
    }

    /// Removes all categories (`catg`).
    pub fn remove_categories(&mut self) {
        self.remove_data_of(&ident::CATEGORY);
    }

    /// Returns all categories formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_categories(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.categories().count() > 1 {
            writeln!(f, "categories:")?;
            for s in self.categories() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.category() {
            writeln!(f, "category: {}", s)?;
        }
        Ok(())
    }
}

/// ### Comment
impl Userdata {
    /// Returns all comments (`©cmt`).
    pub fn comments(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::COMMENT)
    }

    /// Returns the first comment (`©cmt`).
    pub fn comment(&self) -> Option<&str> {
        self.strings_of(&ident::COMMENT).next()
    }

    /// Removes and returns all comments (`©cmt`).
    pub fn take_comments(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::COMMENT)
    }

    /// Removes all and returns the first comment (`©cmt`).
    pub fn take_comment(&mut self) -> Option<String> {
        self.take_strings_of(&ident::COMMENT).next()
    }

    /// Sets all comments (`©cmt`). This will remove all other comments.
    pub fn set_comments(&mut self, comments: impl IntoIterator<Item = String>) {
        let data = comments.into_iter().map(Data::Utf8);
        self.set_all_data(ident::COMMENT, data);
    }

    /// Sets the comment (`©cmt`). This will remove all other comments.
    pub fn set_comment(&mut self, comment: impl Into<String>) {
        self.set_data(ident::COMMENT, Data::Utf8(comment.into()));
    }

    /// Adds all comments (`©cmt`).
    pub fn add_comments(&mut self, comments: impl IntoIterator<Item = String>) {
        let data = comments.into_iter().map(Data::Utf8);
        self.add_all_data(ident::COMMENT, data);
    }

    /// Adds an comment (`©cmt`).
    pub fn add_comment(&mut self, comment: impl Into<String>) {
        self.add_data(ident::COMMENT, Data::Utf8(comment.into()));
    }

    /// Removes all comments (`©cmt`).
    pub fn remove_comments(&mut self) {
        self.remove_data_of(&ident::COMMENT);
    }

    /// Returns all comments formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_comments(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.comments().count() > 1 {
            writeln!(f, "comments:")?;
            for s in self.comments() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.comment() {
            writeln!(f, "comment: {}", s)?;
        }
        Ok(())
    }
}

/// ### Composer
impl Userdata {
    /// Returns all composers (`©wrt`).
    pub fn composers(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::COMPOSER)
    }

    /// Returns the first composer (`©wrt`).
    pub fn composer(&self) -> Option<&str> {
        self.strings_of(&ident::COMPOSER).next()
    }

    /// Removes and returns all composers (`©wrt`).
    pub fn take_composers(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::COMPOSER)
    }

    /// Removes all and returns the first composer (`©wrt`).
    pub fn take_composer(&mut self) -> Option<String> {
        self.take_strings_of(&ident::COMPOSER).next()
    }

    /// Sets all composers (`©wrt`). This will remove all other composers.
    pub fn set_composers(&mut self, composers: impl IntoIterator<Item = String>) {
        let data = composers.into_iter().map(Data::Utf8);
        self.set_all_data(ident::COMPOSER, data);
    }

    /// Sets the composer (`©wrt`). This will remove all other composers.
    pub fn set_composer(&mut self, composer: impl Into<String>) {
        self.set_data(ident::COMPOSER, Data::Utf8(composer.into()));
    }

    /// Adds all composers (`©wrt`).
    pub fn add_composers(&mut self, composers: impl IntoIterator<Item = String>) {
        let data = composers.into_iter().map(Data::Utf8);
        self.add_all_data(ident::COMPOSER, data);
    }

    /// Adds an composer (`©wrt`).
    pub fn add_composer(&mut self, composer: impl Into<String>) {
        self.add_data(ident::COMPOSER, Data::Utf8(composer.into()));
    }

    /// Removes all composers (`©wrt`).
    pub fn remove_composers(&mut self) {
        self.remove_data_of(&ident::COMPOSER);
    }

    /// Returns all composers formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_composers(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.composers().count() > 1 {
            writeln!(f, "composers:")?;
            for s in self.composers() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.composer() {
            writeln!(f, "composer: {}", s)?;
        }
        Ok(())
    }
}

/// ### Custom genre
impl Userdata {
    /// Returns all custom genres (`©gen`).
    pub fn custom_genres(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::CUSTOM_GENRE)
    }

    /// Returns the first custom genre (`©gen`).
    pub fn custom_genre(&self) -> Option<&str> {
        self.strings_of(&ident::CUSTOM_GENRE).next()
    }

    /// Removes and returns all custom genres (`©gen`).
    pub fn take_custom_genres(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::CUSTOM_GENRE)
    }

    /// Removes all and returns the first custom genre (`©gen`).
    pub fn take_custom_genre(&mut self) -> Option<String> {
        self.take_strings_of(&ident::CUSTOM_GENRE).next()
    }

    /// Sets all custom genres (`©gen`). This will remove all other custom genres.
    pub fn set_custom_genres(&mut self, custom_genres: impl IntoIterator<Item = String>) {
        let data = custom_genres.into_iter().map(Data::Utf8);
        self.set_all_data(ident::CUSTOM_GENRE, data);
    }

    /// Sets the custom genre (`©gen`). This will remove all other custom genres.
    pub fn set_custom_genre(&mut self, custom_genre: impl Into<String>) {
        self.set_data(ident::CUSTOM_GENRE, Data::Utf8(custom_genre.into()));
    }

    /// Adds all custom genres (`©gen`).
    pub fn add_custom_genres(&mut self, custom_genres: impl IntoIterator<Item = String>) {
        let data = custom_genres.into_iter().map(Data::Utf8);
        self.add_all_data(ident::CUSTOM_GENRE, data);
    }

    /// Adds an custom genre (`©gen`).
    pub fn add_custom_genre(&mut self, custom_genre: impl Into<String>) {
        self.add_data(ident::CUSTOM_GENRE, Data::Utf8(custom_genre.into()));
    }

    /// Removes all custom genres (`©gen`).
    pub fn remove_custom_genres(&mut self) {
        self.remove_data_of(&ident::CUSTOM_GENRE);
    }

    /// Returns all custom genres formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_custom_genres(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.custom_genres().count() > 1 {
            writeln!(f, "custom genres:")?;
            for s in self.custom_genres() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.custom_genre() {
            writeln!(f, "custom genre: {}", s)?;
        }
        Ok(())
    }
}

/// ### Description
impl Userdata {
    /// Returns all descriptions (`desc`).
    pub fn descriptions(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::DESCRIPTION)
    }

    /// Returns the first description (`desc`).
    pub fn description(&self) -> Option<&str> {
        self.strings_of(&ident::DESCRIPTION).next()
    }

    /// Removes and returns all descriptions (`desc`).
    pub fn take_descriptions(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::DESCRIPTION)
    }

    /// Removes all and returns the first description (`desc`).
    pub fn take_description(&mut self) -> Option<String> {
        self.take_strings_of(&ident::DESCRIPTION).next()
    }

    /// Sets all descriptions (`desc`). This will remove all other descriptions.
    pub fn set_descriptions(&mut self, descriptions: impl IntoIterator<Item = String>) {
        let data = descriptions.into_iter().map(Data::Utf8);
        self.set_all_data(ident::DESCRIPTION, data);
    }

    /// Sets the description (`desc`). This will remove all other descriptions.
    pub fn set_description(&mut self, description: impl Into<String>) {
        self.set_data(ident::DESCRIPTION, Data::Utf8(description.into()));
    }

    /// Adds all descriptions (`desc`).
    pub fn add_descriptions(&mut self, descriptions: impl IntoIterator<Item = String>) {
        let data = descriptions.into_iter().map(Data::Utf8);
        self.add_all_data(ident::DESCRIPTION, data);
    }

    /// Adds an description (`desc`).
    pub fn add_description(&mut self, description: impl Into<String>) {
        self.add_data(ident::DESCRIPTION, Data::Utf8(description.into()));
    }

    /// Removes all descriptions (`desc`).
    pub fn remove_descriptions(&mut self) {
        self.remove_data_of(&ident::DESCRIPTION);
    }

    /// Returns all descriptions formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_descriptions(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.descriptions().count() > 1 {
            writeln!(f, "descriptions:")?;
            for s in self.descriptions() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.description() {
            writeln!(f, "description: {}", s)?;
        }
        Ok(())
    }
}

/// ### Grouping
impl Userdata {
    /// Returns all groupings (`©grp`).
    pub fn groupings(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::GROUPING)
    }

    /// Returns the first grouping (`©grp`).
    pub fn grouping(&self) -> Option<&str> {
        self.strings_of(&ident::GROUPING).next()
    }

    /// Removes and returns all groupings (`©grp`).
    pub fn take_groupings(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::GROUPING)
    }

    /// Removes all and returns the first grouping (`©grp`).
    pub fn take_grouping(&mut self) -> Option<String> {
        self.take_strings_of(&ident::GROUPING).next()
    }

    /// Sets all groupings (`©grp`). This will remove all other groupings.
    pub fn set_groupings(&mut self, groupings: impl IntoIterator<Item = String>) {
        let data = groupings.into_iter().map(Data::Utf8);
        self.set_all_data(ident::GROUPING, data);
    }

    /// Sets the grouping (`©grp`). This will remove all other groupings.
    pub fn set_grouping(&mut self, grouping: impl Into<String>) {
        self.set_data(ident::GROUPING, Data::Utf8(grouping.into()));
    }

    /// Adds all groupings (`©grp`).
    pub fn add_groupings(&mut self, groupings: impl IntoIterator<Item = String>) {
        let data = groupings.into_iter().map(Data::Utf8);
        self.add_all_data(ident::GROUPING, data);
    }

    /// Adds an grouping (`©grp`).
    pub fn add_grouping(&mut self, grouping: impl Into<String>) {
        self.add_data(ident::GROUPING, Data::Utf8(grouping.into()));
    }

    /// Removes all groupings (`©grp`).
    pub fn remove_groupings(&mut self) {
        self.remove_data_of(&ident::GROUPING);
    }

    /// Returns all groupings formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_groupings(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.groupings().count() > 1 {
            writeln!(f, "groupings:")?;
            for s in self.groupings() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.grouping() {
            writeln!(f, "grouping: {}", s)?;
        }
        Ok(())
    }
}

/// ### Keyword
impl Userdata {
    /// Returns all keywords (`keyw`).
    pub fn keywords(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::KEYWORD)
    }

    /// Returns the first keyword (`keyw`).
    pub fn keyword(&self) -> Option<&str> {
        self.strings_of(&ident::KEYWORD).next()
    }

    /// Removes and returns all keywords (`keyw`).
    pub fn take_keywords(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::KEYWORD)
    }

    /// Removes all and returns the first keyword (`keyw`).
    pub fn take_keyword(&mut self) -> Option<String> {
        self.take_strings_of(&ident::KEYWORD).next()
    }

    /// Sets all keywords (`keyw`). This will remove all other keywords.
    pub fn set_keywords(&mut self, keywords: impl IntoIterator<Item = String>) {
        let data = keywords.into_iter().map(Data::Utf8);
        self.set_all_data(ident::KEYWORD, data);
    }

    /// Sets the keyword (`keyw`). This will remove all other keywords.
    pub fn set_keyword(&mut self, keyword: impl Into<String>) {
        self.set_data(ident::KEYWORD, Data::Utf8(keyword.into()));
    }

    /// Adds all keywords (`keyw`).
    pub fn add_keywords(&mut self, keywords: impl IntoIterator<Item = String>) {
        let data = keywords.into_iter().map(Data::Utf8);
        self.add_all_data(ident::KEYWORD, data);
    }

    /// Adds an keyword (`keyw`).
    pub fn add_keyword(&mut self, keyword: impl Into<String>) {
        self.add_data(ident::KEYWORD, Data::Utf8(keyword.into()));
    }

    /// Removes all keywords (`keyw`).
    pub fn remove_keywords(&mut self) {
        self.remove_data_of(&ident::KEYWORD);
    }

    /// Returns all keywords formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_keywords(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.keywords().count() > 1 {
            writeln!(f, "keywords:")?;
            for s in self.keywords() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.keyword() {
            writeln!(f, "keyword: {}", s)?;
        }
        Ok(())
    }
}

/// ### Lyricist
impl Userdata {
    /// Returns all lyricists (`----:com.apple.iTunes:LYRICIST`).
    pub fn lyricists(&self) -> impl Iterator<Item=&str> {
        self.strings_of(&ident::LYRICIST)
    }

    /// Returns the first lyricist (`----:com.apple.iTunes:LYRICIST`).
    pub fn lyricist(&self) -> Option<&str> {
        self.strings_of(&ident::LYRICIST).next()
    }

    /// Removes and returns all lyricists (`----:com.apple.iTunes:LYRICIST`).
    pub fn take_lyricists(&mut self) -> impl Iterator<Item=String> + '_ {
        self.take_strings_of(&ident::LYRICIST)
    }

    /// Removes all and returns the first lyricist (`----:com.apple.iTunes:LYRICIST`).
    pub fn take_lyricist(&mut self) -> Option<String> {
        self.take_strings_of(&ident::LYRICIST).next()
    }

    /// Sets all lyricists (`----:com.apple.iTunes:LYRICIST`). This will remove all other lyricists.
    pub fn set_lyricists(&mut self, lyricists: impl IntoIterator<Item = String>) {
        let data = lyricists.into_iter().map(Data::Utf8);
        self.set_all_data(ident::LYRICIST, data);
    }

    /// Sets the lyricist (`----:com.apple.iTunes:LYRICIST`). This will remove all other lyricists.
    pub fn set_lyricist(&mut self, lyricist: impl Into<String>) {
        self.set_data(ident::LYRICIST, Data::Utf8(lyricist.into()));
    }

    /// Adds all lyricists (`----:com.apple.iTunes:LYRICIST`).
    pub fn add_lyricists(&mut self, lyricists: impl IntoIterator<Item = String>) {
        let data = lyricists.into_iter().map(Data::Utf8);
        self.add_all_data(ident::LYRICIST, data);
    }

    /// Adds an lyricist (`----:com.apple.iTunes:LYRICIST`).
    pub fn add_lyricist(&mut self, lyricist: impl Into<String>) {
        self.add_data(ident::LYRICIST, Data::Utf8(lyricist.into()));
    }

    /// Removes all lyricists (`----:com.apple.iTunes:LYRICIST`).
    pub fn remove_lyricists(&mut self) {
        self.remove_data_of(&ident::LYRICIST);
    }

    /// Returns all lyricists formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_lyricists(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if self.lyricists().count() > 1 {
            writeln!(f, "lyricists:")?;
            for s in self.lyricists() {
                writeln!(f, "    {}", s)?;
            }
        } else if let Some(s) = self.lyricist() {
            writeln!(f, "lyricist: {}", s)?;
        }
        Ok(())
    }
}

/// ### Compilation
impl Userdata {
    /// Returns the compilation flag (`cpil`).
    pub fn compilation(&self) -> bool {
        let vec = match self.bytes_of(&ident::COMPILATION).next() {
            Some(v) => v,
            None => return false,
        };
        vec.first().map(|&v| v == 1).unwrap_or(false)
    }

    /// Sets the compilation flag to true (`cpil`).
    pub fn set_compilation(&mut self) {
        self.set_data(ident::COMPILATION, Data::BeSigned(vec![1]));
    }

    /// Removes the compilation flag (`cpil`).
    pub fn remove_compilation(&mut self) {
        self.remove_data_of(&ident::COMPILATION)
    }

    /// Returns the compilation formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_compilation(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.compilation() {
            true => writeln!(f, "compilation"),
            false => Ok(()),
        }
    }
}

/// ### Gapless playback
impl Userdata {
    /// Returns the gapless playback flag (`pgap`).
    pub fn gapless_playback(&self) -> bool {
        let vec = match self.bytes_of(&ident::GAPLESS_PLAYBACK).next() {
            Some(v) => v,
            None => return false,
        };
        vec.first().map(|&v| v == 1).unwrap_or(false)
    }

    /// Sets the gapless playback flag to true (`pgap`).
    pub fn set_gapless_playback(&mut self) {
        self.set_data(ident::GAPLESS_PLAYBACK, Data::BeSigned(vec![1]));
    }

    /// Removes the gapless playback flag (`pgap`).
    pub fn remove_gapless_playback(&mut self) {
        self.remove_data_of(&ident::GAPLESS_PLAYBACK)
    }

    /// Returns the gapless playback formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_gapless_playback(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.gapless_playback() {
            true => writeln!(f, "gapless playback"),
            false => Ok(()),
        }
    }
}

/// ### Show movement
impl Userdata {
    /// Returns the show movement flag (`shwm`).
    pub fn show_movement(&self) -> bool {
        let vec = match self.bytes_of(&ident::SHOW_MOVEMENT).next() {
            Some(v) => v,
            None => return false,
        };
        vec.first().map(|&v| v == 1).unwrap_or(false)
    }

    /// Sets the show movement flag to true (`shwm`).
    pub fn set_show_movement(&mut self) {
        self.set_data(ident::SHOW_MOVEMENT, Data::BeSigned(vec![1]));
    }

    /// Removes the show movement flag (`shwm`).
    pub fn remove_show_movement(&mut self) {
        self.remove_data_of(&ident::SHOW_MOVEMENT)
    }

    /// Returns the show movement formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_show_movement(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.show_movement() {
            true => writeln!(f, "show movement"),
            false => Ok(()),
        }
    }
}

/// ### Bpm
impl Userdata {
    /// Returns the bpm (`tmpo`)
    pub fn bpm(&self) -> Option<u16> {
        let vec = self.bytes_of(&ident::BPM).next()?;
        be_int!(vec, 0, u16)
    }

    /// Sets the bpm (`tmpo`)
    pub fn set_bpm(&mut self, bpm: u16) {
        let vec: Vec<u8> = bpm.to_be_bytes().to_vec();
        self.set_data(ident::BPM, Data::BeSigned(vec));
    }

    /// Removes the bpm (`tmpo`).
    pub fn remove_bpm(&mut self) {
        self.remove_data_of(&ident::BPM);
    }

    /// Returns the bpm formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_bpm(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.bpm() {
            Some(s) => writeln!(f, "bpm: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Movement count
impl Userdata {
    /// Returns the movement count (`©mvc`)
    pub fn movement_count(&self) -> Option<u16> {
        let vec = self.bytes_of(&ident::MOVEMENT_COUNT).next()?;
        be_int!(vec, 0, u16)
    }

    /// Sets the movement count (`©mvc`)
    pub fn set_movement_count(&mut self, movement_count: u16) {
        let vec: Vec<u8> = movement_count.to_be_bytes().to_vec();
        self.set_data(ident::MOVEMENT_COUNT, Data::BeSigned(vec));
    }

    /// Removes the movement count (`©mvc`).
    pub fn remove_movement_count(&mut self) {
        self.remove_data_of(&ident::MOVEMENT_COUNT);
    }

    /// Returns the movement count formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_movement_count(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.movement_count() {
            Some(s) => writeln!(f, "movement count: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Movement index
impl Userdata {
    /// Returns the movement index (`©mvi`)
    pub fn movement_index(&self) -> Option<u16> {
        let vec = self.bytes_of(&ident::MOVEMENT_INDEX).next()?;
        be_int!(vec, 0, u16)
    }

    /// Sets the movement index (`©mvi`)
    pub fn set_movement_index(&mut self, movement_index: u16) {
        let vec: Vec<u8> = movement_index.to_be_bytes().to_vec();
        self.set_data(ident::MOVEMENT_INDEX, Data::BeSigned(vec));
    }

    /// Removes the movement index (`©mvi`).
    pub fn remove_movement_index(&mut self) {
        self.remove_data_of(&ident::MOVEMENT_INDEX);
    }

    /// Returns the movement index formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_movement_index(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.movement_index() {
            Some(s) => writeln!(f, "movement index: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Tv episode
impl Userdata {
    /// Returns the tv episode (`tves`)
    pub fn tv_episode(&self) -> Option<u32> {
        let vec = self.bytes_of(&ident::TV_EPISODE).next()?;
        be_int!(vec, 0, u32)
    }

    /// Sets the tv episode (`tves`)
    pub fn set_tv_episode(&mut self, tv_episode: u32) {
        let vec: Vec<u8> = tv_episode.to_be_bytes().to_vec();
        self.set_data(ident::TV_EPISODE, Data::BeSigned(vec));
    }

    /// Removes the tv episode (`tves`).
    pub fn remove_tv_episode(&mut self) {
        self.remove_data_of(&ident::TV_EPISODE);
    }

    /// Returns the tv episode formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_tv_episode(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.tv_episode() {
            Some(s) => writeln!(f, "tv episode: {}", s),
            None => Ok(()),
        }
    }
}

/// ### Tv season
impl Userdata {
    /// Returns the tv season (`tvsn`)
    pub fn tv_season(&self) -> Option<u32> {
        let vec = self.bytes_of(&ident::TV_SEASON).next()?;
        be_int!(vec, 0, u32)
    }

    /// Sets the tv season (`tvsn`)
    pub fn set_tv_season(&mut self, tv_season: u32) {
        let vec: Vec<u8> = tv_season.to_be_bytes().to_vec();
        self.set_data(ident::TV_SEASON, Data::BeSigned(vec));
    }

    /// Removes the tv season (`tvsn`).
    pub fn remove_tv_season(&mut self) {
        self.remove_data_of(&ident::TV_SEASON);
    }

    /// Returns the tv season formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_tv_season(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self.tv_season() {
            Some(s) => writeln!(f, "tv season: {}", s),
            None => Ok(()),
        }
    }
}
