use std::fmt::Write;

const INPUT: &str = include_str!("../../src/tag/userdata/generate.toml");
const OUTPUT_PATH: &str = "src/tag/userdata/generated.rs";

const HEADER: &str = "\
// IMPORTANT: This file is automatically generated!
// Edit the `generate.toml` file and run the code generation from the repository root
// with the following command: `cargo run --manifest-path=gen/Cargo.toml`

use crate::{ident, Data, Userdata};
";

fn main() {
    let input: toml::Table = toml::from_str(INPUT).unwrap();
    let accessors = input["accessors"].as_table().unwrap();

    let mut output = String::from(HEADER);

    for [value_ident, atom_ident] in str_table_iter(&accessors["single_strings"]) {
        single_string_accessor(&mut output, value_ident, atom_ident);
    }
    for [value_ident, atom_ident] in str_table_iter(&accessors["multiple_strings"]) {
        multiple_strings_accessor(&mut output, value_ident, atom_ident);
    }
    for [value_ident, atom_ident] in str_table_iter(&accessors["bool_flags"]) {
        bool_flag_accessor(&mut output, value_ident, atom_ident);
    }
    for [value_ident, atom_ident] in str_table_iter(&accessors["u16_ints"]) {
        u16_int_accessor(&mut output, value_ident, atom_ident);
    }
    for [value_ident, atom_ident] in str_table_iter(&accessors["u32_ints"]) {
        u32_int_accessor(&mut output, value_ident, atom_ident);
    }

    std::fs::write(OUTPUT_PATH, &output).unwrap();
}

fn str_table_iter(value: &toml::Value) -> impl Iterator<Item = [&str; 2]> {
    let table = value.as_table().unwrap();
    table.iter().map(|(key, val)| {
        let val_str = val.as_str().unwrap();
        [key, val_str]
    })
}

fn base_values(value_ident: &str) -> (String, String, String) {
    let name = value_ident.replace('_', " ");

    let mut name_chars = name.chars();
    let headline = name_chars.next().unwrap().to_uppercase().chain(name_chars).collect::<String>();

    let atom_ident = format!("ident::{}", value_ident.to_uppercase());

    (name, headline, atom_ident)
}

pub fn single_string_accessor(output: &mut String, value_ident: &str, atom_ident_string: &str) {
    let (name, headline, atom_ident) = base_values(value_ident);

    _ = write!(
        output,
        "
/// ### {hl}
impl Userdata {{
    /// Returns the {n} (`{ais}`).
    pub fn {vi}(&self) -> Option<&str> {{
        self.strings_of(&{ai}).next()
    }}

    /// Removes and returns the {n} (`{ais}`).
    pub fn take_{vi}(&mut self) -> Option<String> {{
        self.take_strings_of(&{ai}).next()
    }}

    /// Sets the {n} (`{ais}`).
    pub fn set_{vi}(&mut self, {vi}: impl Into<String>) {{
        self.set_data({ai}, Data::Utf8({vi}.into()));
    }}

    /// Removes the {n} (`{ais}`).
    pub fn remove_{vi}(&mut self) {{
        self.remove_data_of(&{ai});
    }}

    /// Returns the {n} formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_{vi}(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self.{vi}() {{
            Some(s) => writeln!(f, \"{n}: {{}}\", s),
            None => Ok(()),
        }}
    }}
}}
",
        hl = headline,
        n = name,
        ais = atom_ident_string,
        vi = value_ident,
        ai = atom_ident,
    );
}

pub fn multiple_strings_accessor(
    output: &mut String,
    value_ident: &str,
    atom_ident_string: &str,
) {
    let (name, headline, atom_ident) = base_values(value_ident);

    let mut value_ident_plural = value_ident.to_string();
    if value_ident_plural.ends_with('y') {
        value_ident_plural.pop();
        value_ident_plural.push_str("ies");
    } else {
        value_ident_plural.push('s');
    };

    let name_plural = value_ident_plural.replace('_', " ");

    _ = write!(
        output,
        "
/// ### {hl}
impl Userdata {{
    /// Returns all {np} (`{ais}`).
    pub fn {vip}(&self) -> impl Iterator<Item=&str> {{
        self.strings_of(&{ai})
    }}

    /// Returns the first {n} (`{ais}`).
    pub fn {vi}(&self) -> Option<&str> {{
        self.strings_of(&{ai}).next()
    }}

    /// Removes and returns all {np} (`{ais}`).
    pub fn take_{vip}(&mut self) -> impl Iterator<Item=String> + '_ {{
        self.take_strings_of(&{ai})
    }}

    /// Removes all and returns the first {n} (`{ais}`).
    pub fn take_{vi}(&mut self) -> Option<String> {{
        self.take_strings_of(&{ai}).next()
    }}

    /// Sets all {np} (`{ais}`). This will remove all other {np}.
    pub fn set_{vip}(&mut self, {vip}: impl IntoIterator<Item = String>) {{
        let data = {vip}.into_iter().map(Data::Utf8);
        self.set_all_data({ai}, data);
    }}

    /// Sets the {n} (`{ais}`). This will remove all other {np}.
    pub fn set_{vi}(&mut self, {vi}: impl Into<String>) {{
        self.set_data({ai}, Data::Utf8({vi}.into()));
    }}

    /// Adds all {np} (`{ais}`).
    pub fn add_{vip}(&mut self, {vip}: impl IntoIterator<Item = String>) {{
        let data = {vip}.into_iter().map(Data::Utf8);
        self.add_all_data({ai}, data);
    }}

    /// Adds an {n} (`{ais}`).
    pub fn add_{vi}(&mut self, {vi}: impl Into<String>) {{
        self.add_data({ai}, Data::Utf8({vi}.into()));
    }}

    /// Removes all {np} (`{ais}`).
    pub fn remove_{vip}(&mut self) {{
        self.remove_data_of(&{ai});
    }}

    /// Returns all {np} formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_{vip}(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        if self.{vip}().count() > 1 {{
            writeln!(f, \"{np}:\")?;
            for s in self.{vip}() {{
                writeln!(f, \"    {{}}\", s)?;
            }}
        }} else if let Some(s) = self.{vi}() {{
            writeln!(f, \"{n}: {{}}\", s)?;
        }}
        Ok(())
    }}
}}
",
        hl = headline,
        n = name,
        np = name_plural,
        ais = atom_ident_string,
        vi = value_ident,
        vip = value_ident_plural,
        ai = atom_ident,
    );
}

pub fn bool_flag_accessor(output: &mut String, value_ident: &str, atom_ident_string: &str) {
    let (name, headline, atom_ident) = base_values(value_ident);

    _ = write!(
        output,
        "
/// ### {hl}
impl Userdata {{
    /// Returns the {n} flag (`{ais}`).
    pub fn {vi}(&self) -> bool {{
        let vec = match self.bytes_of(&{ai}).next() {{
            Some(v) => v,
            None => return false,
        }};
        vec.first().map(|&v| v == 1).unwrap_or(false)
    }}

    /// Sets the {n} flag to true (`{ais}`).
    pub fn set_{vi}(&mut self) {{
        self.set_data({ai}, Data::BeSigned(vec![1]));
    }}

    /// Removes the {n} flag (`{ais}`).
    pub fn remove_{vi}(&mut self) {{
        self.remove_data_of(&{ai})
    }}

    /// Returns the {n} formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_{vi}(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self.{vi}() {{
            true => writeln!(f, \"{n}\"),
            false => Ok(()),
        }}
    }}
}}
",
        hl = headline,
        n = name,
        ais = atom_ident_string,
        vi = value_ident,
        ai = atom_ident,
    );
}

pub fn u16_int_accessor(output: &mut String, value_ident: &str, atom_ident_string: &str) {
    let (name, headline, atom_ident) = base_values(value_ident);

    _ = write!(
        output,
        "
/// ### {hl}
impl Userdata {{
    /// Returns the {n} (`{ais}`)
    pub fn {vi}(&self) -> Option<u16> {{
        let vec = self.bytes_of(&{ai}).next()?;
        be_int!(vec, 0, u16)
    }}

    /// Sets the {n} (`{ais}`)
    pub fn set_{vi}(&mut self, {vi}: u16) {{
        let vec: Vec<u8> = {vi}.to_be_bytes().to_vec();
        self.set_data({ai}, Data::BeSigned(vec));
    }}

    /// Removes the {n} (`{ais}`).
    pub fn remove_{vi}(&mut self) {{
        self.remove_data_of(&{ai});
    }}

    /// Returns the {n} formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_{vi}(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self.{vi}() {{
            Some(s) => writeln!(f, \"{n}: {{}}\", s),
            None => Ok(()),
        }}
    }}
}}
",
        hl = headline,
        n = name,
        ais = atom_ident_string,
        vi = value_ident,
        ai = atom_ident,
    );
}

pub fn u32_int_accessor(output: &mut String, value_ident: &str, atom_ident_string: &str) {
    let (name, headline, atom_ident) = base_values(value_ident);

    _ = write!(
        output,
        "
/// ### {hl}
impl Userdata {{
    /// Returns the {n} (`{ais}`)
    pub fn {vi}(&self) -> Option<u32> {{
        let vec = self.bytes_of(&{ai}).next()?;
        be_int!(vec, 0, u32)
    }}

    /// Sets the {n} (`{ais}`)
    pub fn set_{vi}(&mut self, {vi}: u32) {{
        let vec: Vec<u8> = {vi}.to_be_bytes().to_vec();
        self.set_data({ai}, Data::BeSigned(vec));
    }}

    /// Removes the {n} (`{ais}`).
    pub fn remove_{vi}(&mut self) {{
        self.remove_data_of(&{ai});
    }}

    /// Returns the {n} formatted in an easily readable way.
    #[allow(unused)]
    pub(crate) fn format_{vi}(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        match self.{vi}() {{
            Some(s) => writeln!(f, \"{n}: {{}}\", s),
            None => Ok(()),
        }}
    }}
}}
",
        hl = headline,
        n = name,
        ais = atom_ident_string,
        vi = value_ident,
        ai = atom_ident,
    );
}
